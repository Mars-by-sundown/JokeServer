<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252"> <title> Distributed Systems -- Elliott  Multithreaded Joke Server and Client &lt;/center&gt; </title>
</head>
<body cz-shortcut-listen="true", style="background-color:rgb(75, 75, 75);">
<font face="Cambria" size="1">

8.1 Updates: 
<ol>
<li> 2023-10-07 Minor clarification on No Secondary Server message.
</li></ol>
<font face="Cambria" size="3">

<center> <h1> Multi-process, Multi-threaded Joke Server and Client
<!--<br>
Introduction&mdash;part II -->
 </h1>
Copyright (c) 2023 By Dr. Clark Elliott with all rights reserved.
<font face="Cambria" size="3">
 </font></center><font face="Cambria" size="3">

<h2> Overview: </h2>

<a href="https://condor.depaul.edu/~elliott/435/hw/programs/Joke/Joke-checklist.html">
Joke-checklist</a> &lt;-- Download and complete the JokeServer checklist. Submit to D2L along with your
Java source code.<p>

In this assignment you will build a pair of multi-threaded servers that accept input from
multiple clients, and return appropriate output. In addition to the basic client-server model,
you will also implement a secondary administration channel to your servers, and manually
maintain the state of all conversations within your distributed application.</p><p>

Each aspect of the specifications requires you to solve a particular client-server problem
while maintaining a conversation within a <i> stateless </i> protocol. The assignment is
designed to give you general-purpose exposure to writing code for a client-server
multi-processing environment, and working with threads, neither of which is trivial.</p><p>

Your finished server is just for fun, but with minor changes it can serve as the basis for a
real, viable, client-server application handling thousands of client conversations
simultaneously. Although we will only be testing with from 1 to 5 clients at a time, your
program should be designed to run thousands of worker threads at once.</p><p>

Note that we will not make these servers thread-safe, which is beyond the scope of this
assignment. However, you are free to do so if you have the expertise and wish to do so. </p><p>

</p><h2> Administration: </h2>



<ul>

<p></p><li> Supplemental links:
<p></p><ul>
<li> <a href="https://condor.depaul.edu/~elliott/435/hw/programs/Joke/joke-pseudo.html"> Joke pseudo code </a>
</li><li> <a href="https://condor.depaul.edu/~elliott/435/hw/programs/Joke/joke-threads.html"> Asynchronous threads </a>
</li><li> <a href="https://condor.depaul.edu/~elliott/435/hw/programs/Joke/JokeServerX.java"> Three named processes from one Java file </a>
</li><li> <a href="https://condor.depaul.edu/~elliott/435/hw/programs/Joke/ModeChanger.java"> Mode Changer method </a>
</li><li> <a href="https://condor.depaul.edu/~elliott/435/hw/programs/Joke/FakeUUID.java"> Fake UUID </a>
</li><li> <a href="https://condor.depaul.edu/~elliott/435/hw/programs/Joke/joke-state.html"> Joke state </a> 
</li></ul>

<p></p></li><li> Submission files for JokeServer ( <i>precise names are rquired</i> ):<pre><b>Joke-checklist.html</b>
<b>JokeServer.java.txt</b> &#8592; Copied from JokeServer.java. Contains the code for three separately
running processes: JokeServer, JokeClient, and JokeClientAdmin. Also included will be your JokeLog.txt and
your Postings files as Java comments at the bottom You will likely have to copy your file from the command
line. (On Windows, use copy. On Mac/unix, use cp).

Executable files generated:<b> JokeServer.class, JokeClient.class</b> and <b> JokeClientAdmin.class</b>
</pre>
<!--JokeClient.java
JokeClientAdmin.java
JokeLog.txt
Joke-postings.txt -->
<p></p></li><li> Additonally, you will create a JokeLog.txt file, then insert it as Java comments at the bottom
of your JokeServer.java (and thus JokeServer.java.txt) file.

<p></p></li><li> Complete the <b> ColorServer </b> first. You are free to use that code as a basis to start this
assignment. <b> Note: you may not copy any other code, including InetServer code, or you will be
guilty of plagiarism. </b> WRITE YOUR OWN CODE.

<p></p></li><li> Update your Joke-checklist as you make progress on the JokeServer assignment.

<p></p></li><li> There is a high priority on our being able to download your JokeServer.java.txt file,
compile JokeServer.java from it, and run your three java applications (JokeServer, JokeClient,
JokeClientAdmin) without any complications.

<p></p></li><li> Make sure that your program will compile when we issue "javac *.java" (twice) at the
command line prompt from within the directory where the java code resides. For this class, for
grading purposes, NEVER use java packages. That is, the <i> package </i> statement should not
appear anywhere in your source code.<p>

<!--
<p><li>
So, even
though this may not be the most elegant coding style, put all your source files in <strong> one
directory,</strong> along with your checklist, the JokeLog.txt, and so on (no .class files!)
then zip together before submitting to D2L. -->

</p><p></p></li><li> Submit to D2L well before the deadline.

<!--
The filenames MUST be precise because we use automated scripts as part of the grading process,
including with the various plagiarism checkers. Zip all these files together and submit the one
standard .zip file to the JokeServer D2L dropbox.  Make sure that you are familiar with the assignment
submission rules. Programs that do not precisely conform to the rules will not be
graded. Please do not ask for an exception to this policy. <p>

<p> <li> Additionally, concatenate your three JokeServer Java source code files into one file
(.docx, or .html with .txt as a last option) for submission to the JokeServerTII D2L Dropbox
link for plagiarism checking. CHECK YOUR SUBMISSION to see if it will be flagged for
plagirism. [In D2L, click on the number link showing the number of submissions you've made and
follow this path to retrieve your plagiarism report.] There may be some minor overlap with the
work of others, but the overall percentage should be low, and your comments should always be
unique. If you include some of the ColorServer code I provide (which is allowed) it will be flagged, but we
are not concerned about that. <p>

Your concatenated files will not be used for compilation and you need not be concerned about
formatting, but the TEXT MUST BE THE SAME as the JokeServer Java files you have submitted for
grading, and the single TII file must be readable by the plagiarism checker.
-->

<p></p></li><li> Be sure to include the required java header file as comments at the top of of your java file.<p>

</p><p></p></li><li> Allow yourself enough time to get a basic version of the JokeServer running. Debugging
TCP/IP on your machine, having difficulties wtih your firewall, spawning runaway processes,
etc. comes with the territory, and you should not underestimate the amount of time this will
take you during the initial phases of this project.<p>

</p><p></p></li><li> <b> JokeLog.txt</b> (Will later be inserted at the bottom of JokeServer.java as Java
comments.) Capture the console output from your running programs so that the output�showing
your working processes in each of the three terminal windows�can be placed in your JokeLog.txt
file. Manual <b> Copy and Paste </b> from the console is probably the easiest scheme, and
exactly what I suggest. I do NOT recommend writing to a file, because it takes a lot more work
and you'll have to address having three output streams from at least three running processes in
three files that later have to get concatenated together. <i> Don't waste time making the
output fancy. </i>

<p></p></li><li> Note that you have to maintain a theoretically unlimited number of arrays, or other
data structures, to keep track of client state�one for each conversation�for a
theoretically unlimited number of Joke Clients; you have to connect from two different kinds of
clients (Jokeclient and JokeClientAdmin); and so on. Each of these steps may take some thought,
so leave plenty of time to get this assignment finished. <p>

</p><p></p></li><li> Allow yourself enough time to prepare the D2L submisison of your work <i> exactly </i> as
specified. This may take some thought and some experimentation the first time you do this. For
example, your programs must compile and run from the command line. You should NOT assume that
you can get this done at the last minute. And, you must get a TII report. <p>

</p><p></p></li><li> I <i> strongly </i> recommend that you complete this assignment incrementally: Make
small additions to the code at a time, while always maintaining a <i>running</i> program.

<p></p></li><li> Read this whole assignment page before you get started so you know where all the hints, links
and explanations are.

</li></ul>

<hr>

<h2> Suggested Development Order: </h2>

<ol>

<p> </p><li> You can develop as you wish, but following is the partial, incremental development
order I recommend. After each step, clean up the interface code as necessary to meet the
console input and output specifications. You can use the checklist as a guide, and should
ypdate your checklist as you complete steps. Comment your code <i> during development </i>.<p>

</p><p></p></li><li> Starting with your running ColorServer code: (a) rename the client and server classes
to JokeServer and JokeClient, (b) remove the ColorServer <i> application code </i> that selects
and sends colors (but leave the serializing and network code in place, leave in the basic
client and server loops, and the network connection and serialization architecture. Finally,
(c) modify the code to return a single joke from the your server as soon as the client
connects.<p>

</p><p></p></li><li> Copy your JokeClient class code to a JokeClientAdmin class. Change the port
at which it is connecting to the server. Modify your JokeServer to run a second thread in a
server loop listening for JokeClientAdmin connections (see example code below). Connect from
the admin client and automatically toggle the server mode between joke and proverb on each
connection. Display on both the server console and the admin client console what the mode is
each time you toggle. If you are not clear on how to change the server mode in one method (and
thread�e.g. the Admin Worker) and read it in another (e.g. the Joke Worker) you can refer
to this <a href="https://condor.depaul.edu/~elliott/435/hw/programs/Joke/ModeChanger.java"> Mode Changer Method </a> as one way you might want to do this.

<p> </p></li><li> You can see how to generate three executable, named .class files fron one Java source
file from this <a href="https://condor.depaul.edu/~elliott/435/hw/programs/Joke/JokeServerX.java"> three executables from one Java file </a> code.

<p></p></li><li> Return either a single joke or a single proverb to the JokeClient depending
on the server mode.

<p></p></li><li> At this point you should be presenting <i> console output </i> in each of your three
terminal windows, with regular announcements about what your three process are doing. Later,
using Copy and Paste, you will copy this output to your JokeLog.txt file.

<p></p></li><li> Return four jokes in order: JA, JB, JC, JD, then repeat over and over, and do the same
for proverbs PA, PB, PC, PD, etc.

<p></p></li><li> At the end of each joke cycle and proverb cycle, announce on the console "JOKE CYCLE
COMPLETED" or "PROVERB CYCLE COMPLETED."

<p></p></li><li> Connect from multiple Joke Clients and verify that the previous step works for <i> each client,
independently </i> without interference from other clients. THIS IS IMPORTANT. You will need to
have a separate data structure saving each conversation�one for each Joke Client. In
theory you should be able to support 10,000 independent conversations with your code.

<p></p></li><li> Return interleaved jokes and proverbs, depending on server mode at the time of any given
request, without losing track of where you are in the JA,JB,JC,JD cycle of jokes, and the
PA,PB,PC,PD cycle of proverbs for one client, verifying that there is no intereference in the
two respective cycle orders for each of jokes and proverbs. So, (without randomization) you
might have JA, PA, PB, JB, JC, JD, PC, PD, JA, JB, PA...<p>

</p></li><li> Return interleaved jokes and proverbs without losing track of where you are in the
JA,JB,JC,JD cycle of jokes, and the PA,PB,PC,PD cycle of proverbs for multiple clients,
verifying that there is no interference from switching server mode from joke to proverb, and no
interference between any one of your multiple clients and another. <p>

</p></li><li> Parse the user name in the JokeClient <i> before </i> entering the request loop. Insert
the user's name right after the "JA", "JB", "PA", "PB", etc. designation, and before the joke
or proverb. For novice programmers this string processing can be hard. Do this toward the
end. It is not a particularly critical part of the assignment. Utility code tips and questions
on string manipulation in java on the class D2L forums is encouraged. Example: "JA Joseph: Why
did the chicken cross the road? To get to the other side!"

</li><li> Re-randomize the jokes, and proverbs for each client conversation at the start of each
four-item joke and proverb cycle. (The J and P labels stay with the jokes.) Veryify that the
randomization of jokes and proverbs for one client conversation still does not interfere with any
other client conversation. Because randomizing makes development confusing, do this toward the end.

</li><li> Go through your entire program to verify that ALL specifications are met regarding file
naming, comments, program logic, console input, and output.<p>

</p></li><li> Make sure your JokeClient and JokeClientAdmin processes will accept a first argument with a
different domain name or IP address. Run your clients and server on different machines if it is
practical for you to do so. Take some care that your firewall does not interfere with you
running your programs across the network. [To find the IP address of your machine under
Windows, type "ipconfig" at a command prompt; use "ifconfig" under unix/Mac.]

<p></p></li><li> Once your default JokeServer is fully working, proceed with the following steps. Make
SURE that when no arguments are passed to your client java programs they run at the default
locations, as given in the specifications.

<p> </p></li><li> Change your JokeServer to accept an argument (see below) indicating that the JokeServer
should run at the secondary server port number, rather than at the default server port
number. The intent is that this will only happen after the first, default, JokeServer is
already running at the default port.

<p> </p></li><li> Modify your JokeClient and JokeClientAdmin programs so that when they are given two
arguments, the first argument will point to the domain name or IP address of the server, and
the second argument, if present will be used as IP address of a second server.<p>

</p></li></ol>




<h2> Joke-postings: </h2>

You are required to make at least two scholarly postings in the D2L discussion forums
JokeServer thread. A scholarly post can be any of, e.g., a discussion thread you start on design aspects
of the JokeServer or clients and servers in general, bragging rights for some interesting extra feature you
plan on implementing, a well-formed question about how to implement or design the JokeServer,
bigger-picture ideas about scale-up design considerations, or data-protection
considerations. You can include <i> annotated </i> URLs as part of your discussion. Favorite
topics might have to do with discussions about maintaining conversation state. Or, you can
<b> reply to any of the above </b> that others have posted. Answers to coding or design questions are
always a big hit. Postings that initiate or take part in <i>discussions </i> are always more
highly prized. Submit your two (or more) postings with your Java code�at the bottom of
JokeServer.java as Java comments.

<h2> Multi-threaded Joke and Proverb Server: </h2>

<h3> JokeServer Conventions </h3>

<ul>

<p></p><li> Communication between client and server <i> must </i> be via serialized Java objects, as
was done in the Color Server. You are not allowed to use InetServer code.

</li><li> Use "localhost" or "127.0.0.1" as the default IP address/domain name location for your
JokeServer. Use 4545 as the default port for your JokeServer, and 4546 for the secondary
port.

<p></p></li><li> The JokeServer and JokeClients must run (in perpetual joke mode) without ever starting
the JokeClientAdmin process. It is <i> required </i> that we be able to start and stop the
JokeClientAdmin at any time without affecting the running of the system. When we stop either of
the running state-maintaining processes (either JokeServer and any JokeClient) the system
becomes <i> undefined,</i> which means you don't have to worry about it for this assignment. If
you gracefully shut down your system that is nice, but you can also simply let it blow up.

<p></p></li><li> We must be able to start your clients and servers <i> in any order </i>.

<p></p></li><li> If your server or client has odd behavior, print a note about this on the console at
startup, and discuss it in the notes at the bottom of your checklist. <p>

</p></li><li> Use strictly clean, inoffensive jokes and proverbs please. Be respectful to
the grader and your professor.<p>

</p></li><li> Use the following conventions for <strong> command-line arguments </strong> to your
JokeServer, JokeClient, and JokeClientAdmin processes. Note that some of you may not complete
the final step of JokeServer (not a big deal...) in which case you will not have a secondary
server, and will not need to deal with any command-line argumnets for the secondary server.<p>

</p><ol>

<p></p><li> <pre> &gt; java JokeServer [secondary]<br> </pre>

Runs at port 4545 by default, and at port 4546 if "secondary" is
indicated (no square braces typed!).

</li><li> <pre> &gt; java JokeClient &lt;IPaddr&gt; &lt;IPaddr&gt; 
</pre>

If a first argument is present, the client will connect to the server at that IP address or
domain name, otherwise it will use the default of "localhost" or "127.0.0.1"<p>

If the second IP address or domain is indicated the client allows the user
to switch between primary and secondary servers, possibly at different IP
addresses. </p><p>

</p><pre> &gt; java JokeClient localhost localhost
</pre>

...would connect to the local host (127.0.0.1) at ports 4545 for the primary
server, and 4546 for the secondary server.<p>

</p><pre> &gt; java JokeClient localhost 140.192.1.9
</pre>

...would connect to port 4545 on the local host (127.0.0.1) for
the primary server, and port 4546 on 140.192.1.9 for the secondary server.<p>


</p></li><li> <pre> Java JokeClientAdmin &lt;IPaddr&gt; &lt;IPaddr&gt;  </pre>

If a first argument is present, the client will connect to the server at that IP address or
domain name, at port 5050, otherwise it will use the default of "localhost" (127.0.0.1) at port
5050. <p>

If the second IP address or domain is indicated the client allows the user to switch between
primary and secondary servers, possibly at different IP addresses. The administration port for
the secondary server is 5051. </p><p>

</p></li></ol>

</li><li> It is required that your JokeServer[s], JokeClientAdmin, and JokeClient[s] can be started
in any order.

<p></p></li><li> The JokeServer starts in Joke Mode by default. The JokeServer and JokeClient[s] will run
without the JokeClientAmin being started.

<p></p></li><li> If any JokeClient process is stopped, or the JokeServer is stopped, the system becomes
undefined (any behavior is fine, including the whole system blowing up).

<p></p></li><li> The JokeClientAdmin process can be started and stopped at will without otherwise affecting the
client[s] and server[s].

<p></p></li><li> All communications from the secondary server are preceeded by the five characters
"&lt;S2&gt; " &#8592;the last character is a single space.<p>

</p></li><li> Use the following JokeClient and JokeClientAdmin conventions:<p>

</p><ol> 

<li> At startup, print the IP address and port number of the server being used on the client
console. If you are using a secondary server, then print both IP addresses and ports being
used: <pre> Server one: localhost, port 4545 Server two: some.other.ip.net, port 4546 </pre>

</li><li> When using a secondary server, client console or client admin console input of "s" means
toggle from one server to the other: switch from primary to secondary, or secondary to
primary. Print the IP address and port number of the current server whenever a toggle has
occurred. When you have not written code for a secondary server, input of "s" means print the message, "No secondary
server being used" on the console.

<pre>Now communicating with: localhost, port 4545
Now communicating with: localhost, port 5050  [&lt;-- for the Admin client]
</pre>

</li><li> Use "quit" to exit from the client.<p>

</p></li><li> For both types of clients, simply pressing the &lt;Enter&gt; key will take us to the next state
(get a joke or proverb / toggle the server mode). So, to see your system run we can simply keep
pressing the &lt;Enter&gt; key on any of the client consoles.

</li></ol>

<p></p></li><li> For the JokeClient use the following additional conventions:<p>

</p><ol>

<li> Get the user's name <i>before</i> entering the server query loop.<p>

</p></li><li> &lt;Enter&gt; means connect to the current server and request a response. If you are having
difficulty with empty console input, then allow us to enter <i>any</i> string other than "quit"
to get a response, including a single character such as "x". But you MUST tell us this is what
you are looking for.<p>

</p></li></ol>

</li><li> For the JokeClientAdmin use the following additional conventions: <p>

</p><ol>

<li> The JokeClientAdmin connects to the primary JokeServer by default
whenever it is started.<p>

</p></li><li> &lt;Enter&gt; means connect to the current server and tell it to toggle between JokeServer
modes: Joke Mode switches to Proverb Mode, and Proverb Mode switches to Joke Mode. Print the
current mode on the console. <p>

</p></li><li> The JokeClientAdmin connects to both the primary server at port 5050
and the secondary server at port 5051.<p>

</p></li></ol>

</li><li> Jokes have the following format:<pre> JA &lt;username&gt;: &lt;joke body&gt; </pre> ...where
"JA" can be either JA, JB, JC, or JD. Similarly, proverbs have the same format, except with PA,
PB, PC, PD. This will require that you use the Java <i> string processing </i> libraries to
splice together such strings.

<p> </p></li><li> Comments are an important part of your grade. Comment your
<i> pedagogical </i> code as you develop. Never plagiarize your comments!

<p> </p></li><li> You will need to run the JokeServer, JokeClient, and
JokeAdminClient in different command windows as you did with the
ColorServer.<p>

</p><p></p></li><li> Joke label randomizing: The labels (e.g., JA, JB) <i> stay with the joke or
proverb. </i> In other words, when the jokes get randomized, the lables do too.

<p></p></li><li> Joke / proverb interleaving: Suppose you are in Joke Mode and have seen two jokes. Then
you swith to Proverb Mode. At this point, the joke state goes into "suspeneded
animation"�it is frozen in time. When you later return to Joke Mode, you pick up exactly
where you left off (e.g., the third joke in the sequence) without any concern whatsoever about
what happened in Proverb Mode. And, the same is true for proverb state.

</li></ul>

<h3> JokeServer Detailed Specifications: </h3>

<ul>

<p> </p><li> Make sure your JokeClient asks for the user's name [to be used later] <i> before </i>
it enters the request loop. We should never have to enter the user name more than once per process.

<p></p></li><li> Inside of the loop, when the user presses &lt;enter&gt; this signals a connection to the
server. When your JokeClient connects to your JokeServer this initiates an algorithmic process
such that, ultimately, the next joke or proverb is displayed on the console of the
JokeClient. <b> Whether it is a joke or a proverb depends on the current mode of the server. </b>

<p> </p></li><li> Build a template of exactly four jokes and four proverbs for use in your client/server
system. Put "JA " at the beginning of the first joke, "JB " at the beginning of the second, "PC
" at the beginning of the third proverb, and so on to help with debugging, and grading [this is
required]. The letters always stay with the same joke or proverb through the randomizing step.

<p> </p></li><li> For each conversation with a client, complete sets of four jokes, [JA, JB, JC, JD]
and, independently, four proverbs [PA, PB, PC, PD] are returned to the client one at a
time. When all members of the jokes set or of the proverbs set have been returned, then print a
console message that the joke or proverb cycle is complete, and start over at the beginning of
the set.  Multiple clients [theoretcially, many thousands of clients] run simultaneously, and
each client conversation is completely independent of all other client conversations.<p>

</p><p> </p></li><li> Your JokeClientAdmin connects to the server and toggles it to <i> Proverb Mode </i>, or
<i> Joke Mode </i> for ALL subsequent client connections within the respective
conversations.<p>

</p><p></p></li><li> The username must appear (as specified above) as part of each joke or proverb JokeClient
console message. Additionally, the username must appear on the server console as well, each time a
client request is made (e.g., "New client request from user Joseph").


<p> </p></li><li> Once your jokes and proverbs are being returned correctly, without interference
between client conversations, then at the beginning of each joke or proverb cycle, randomize
the jokes or proverbs before starting the cycle again. However, the rule still stands that no
joke or proverb can be repeated as part of a client conversation until ALL the jokes or
proverbs in that cycle have been seen by the client, at which point the cycle (and
randomization) is started all over again.<p>

This radomizing is a small part of the assignment, but think about how this might be done. Did
you implement randomness efficiently? Does your solution scale up for 1,000 jokes?  1,000,000
jokes? Why might a set implementation, possibly with a linked data structure, be useful here,
rather than random access to an array? Note: efficiency in your implementation is desirable,
but will not affect your JokeServer grade. Comments in your code?


</p><p> </p></li><li> Each time a client connects, select the next joke or proverb to
be sent as part of that conversation, and then insert the user's name
into the joke or proverb <i> after </i> the "JA " indication, and <i>
before </i> the body of the joke.

Asssuming the user's name is Joseph, you might start with the template
for our first joke:<pre>JA &lt;name-holder&gt;: Why did the chicken cross the road? To get to the other side!</pre>

The server modifies the template for this client to produce:<pre>JA Joseph: why did the chicken cross the road? To get to the other side!
</pre>

<p> </p></li><li> Proverbs are the same:<pre>PD Joseph: The early bird gets the worm.
</pre>

</li><li> Modify the server to accept a connection at port 5050 from an administration client (and,
later at 5051 for the secondary server). This will take some thought because you will have to
make an <b> asynchronous thread call </b> in your server, initiating a separate thread, to
start a second server listener waiting for JokeAdminClient connections. See the file <a href="https://condor.depaul.edu/~elliott/435/hw/programs/Joke/joke-threads.html"> joke-threads.html </a> for some hints, and the file <a href="https://condor.depaul.edu/~elliott/435/hw/programs/Joke/joke-pseudo.html"> joke-pseudo.html </a> for pseudo code.<p>

</p></li><li> Write a second client, JokeClientAdmin that connects at the administration port and
toggles the server between Joke Mode and Proverb Mode.<p>

</p></li></ul>

<h3> State maintenance: </h3>

<ul>

<li> <i> How </i> you maintain the state of client conversations is up to you, as long as you
always break the connection after each joke, or proverb is returned (because we are writing
explicitly for a connectionless protocol). But this will require some thought before you begin
development. I recommend that you write out your design with pencil and paper before beginning
to write computer code. <p>

The general problem to be solved is that having established a client/server conversation (i.e.,
a history of your previous interactions), then broken the TCP/IP connection between client and
server, how do you retrieve that same conversation next time you connect? (Remember that there
may be 2,000 simultaneous conversations going on.)

</p><p></p></li><li> You have many ways that you can implement state maintenance. For
example:<p>

</p><ol>

<li> MINIMAL COOKIE ON THE CLIENT; FULL STATE ON THE SERVER: You can maintain the state of the
conversation by sending a unique "cookie" (e.g., a UUID would be one way to implement this, or
a <a href="https://condor.depaul.edu/~elliott/435/hw/programs/Joke/FakeUUID.java">large random number </a> unlikely to have a collision) from the client when it first
connects. Pass the "cookie" from the client each time it connects, and use it on the server to
look up the state of the unique client conversation which has been stored there (e.g., in an
array of conversation-state objects). Use this mechanism to guarantee that the client never
gets a joke, or proverb, repeated until ALL of the jokes and proverbs in each respective
four-item cycle have been sent. Then, cycle through all the jokes or proverbs again, after
re-randomizing. <p>

</p></li><li> FULL STATE ON THE CLIENT; <i> NOTHING </i> ON THE SERVER: You can send the entire state
back to the client after updating by the server, and maintain <i> nothing at all </i> on the server
side. That is, read and update the jokes-sent/proverbs-sent "checklist" (sent by the client) at
the server with the new joke or proverb marked as having been sent, and then send the whole
joke/proverb checklist back to the client. Each time the client connects, it sends the entire
state (contained in the checklist, plus the user name) again.<p>

Or, because the only thing you actually need from the server, is what mode it is in, you can
simply send the username to the server (to display on the server console), and get back what
mode the server is in, then do EVERYthing else on the client.

</p><p> </p></li><li> MAINTAIN PART OF THE STATE AT EACH END: You can implement anything in between the above
two schemes, such as keeping the cookie and the joke-state on the client, and the proverb-state
on the server; the cookie and the user name on the client, but the rest of the state on the
server; etc.

<p></p></li><li> <i> NOTHING </i> ON THE CLIENT: It is not possible to implement the JokeServer
this way. <i> Why not? </i> <p>

</p><p></p></li><li> See <a href="https://condor.depaul.edu/~elliott/435/hw/programs/Joke/joke-state.html"> joke-state.html </a> for some
additional pointers on maintaining the state of the client.

</li></ol>
</li></ul>

<h3> Some further notes on state maintenance: </h3>

<ul>

<p></p><li> There are other design elements to consider: For example, suppose you want to store
everything, including the jokes and proverbs on each of your 50,000 clients. What happens if
you hear from your legal department that one of your jokes is now considered libelous and must
be replaced? With this model you have 50,000 jokes to retrieve and replace, including on the
5,000 clients that will not be connected anytime soon, right? Ouch!

<p> </p></li><li> MUST CONNECT TO SERVER: Even if you maintain the entire state of the client
conversation on the JokeClient, and update it there, you cannot determine joke-mode or
proverb-mode without connecting to the server. You can, however, download your four jokes and
four proverbs when you first connect, then, as noted above, just ask the server what mode it is
in each time you re-connect. When the jokes or proverbs are exhausted, you can reconnect to get
them randomized and downloaded again, or just randomize them on the client, depending on your
design and how often you envision the jokes and proverbs being updated.

<p></p></li><li> COOKIE VARIATION: Optionally you could initially send an empty cookie/state structure from
the client at startup time, and have the server assign a value (such as an incremental array
index) when it notices that the cookie or state structure has not been initialized. This allows
the use of a simple counter maintained by the server to identify conversations of various
clients. Thereafter, the client just sends the number assigned, as the cookie. <p>

</p><p></p></li><li> FOR THE TWO-SERVER MODEL: When extending our client / server system to use multiple
servers (see below), we have additional design concerns. Each client will now have <i> two </i>
conversations going�one with each server. If you use the state-maintenance model of
storing everything on the server, and only a UUID/cookie on the client, then you only need to
pass the same UUID to either server, and you'll get put back in the right conversation from
each respective server. If, by contrast, you store everything on the client, you'll have to
maintain <i> two </i> conversation-objects on your client, and send the right one to the right
server each time.

</li></ul>

<ul>

<li> ALL client conversations are entirely indpendent, except that the corpus of joke templates
and proverb templates is the same, and all client coversations use the current server mode to
determine whether a joke or proverb is to be returned to the client.<p>

</p></li><li> QUESTIONS: For a large-scale production system, when is it appropriate to send just a
cookie back to the client? When should the whole state be sent to the client? Suppose that in
place of jokes you were sending 4 GByte database entries? Suppose that instead of a static
joke, you were computing, in real time, some highly cpu-intensive output based on input data
assessed at the server at the time of the request? Which design would you use for each? How
would your solution scale?

</li></ul>

<h3> Extending to two servers, primary and secondary: </h3>

<ul>

<li> Once you have completed the basic single-server model, continue as follows. This portion
of the JokeServer assignment is only worth ten percent, so it is not that big of a deal if you
don't complete it. <p>

</p></li><li> All of the above functionality remains the same. If no arguments are passed to the server,
or the clients, everything MUST continue to work exactly as above, which is the default mode of
operation. <p>

</p></li><li> Your secondary server�<i>using exactly the same code</i>�will run in its own
process in a separate command shell but communicating via different ports.<p>

</p></li><li> Modify your JokeServer to accept an argument, the token
"secondary":<pre> 
&gt; java JokeServer secondary
</pre>

When your JokeServer code detects this argument, it starts the server listening for JokeClient
connections at port 4546. (See the ColorServer for an example of accepting command line
arguments.) Print on the console that this is the secondary server. JokeClientAdmin connections
are at port 5050 for the primary admin server, and 5051 on the secondary admin server.<p>

</p></li><li> All communications from the secondary server to the JokeClient
are preceded by the four characters (plus a trailing space):<pre>&lt;S2&gt;
</pre>

So, for example, a proverb would look like this:<pre> &lt;S2&gt; PD Joseph: The early bird gets
the worm.  </pre>

<p></p></li><li> The two servers are completely independent from one another, and all client conversations
between a server and a client are independent of conversations between that client and the
other server.

<p></p></li><li>Modify your JokeClient and JokeClientAdmin classes so that when they are run as
independent processes and given two arguments, the first argument will point to the domain name
or IP address of the server, and the second argument, if present will be used as IP address of
a second server.

<p> </p></li><li> Hint: If you store the entire state of the conversation on the server and pass a "reminder
token" (cookie) to the server to go find your state when you connect, you only have to pass the
same token to the second server, and everything else is done. If you store the entire state on
the client, you only have to keep two track of two conversation states on your client, and send
the right one to the right server when you connect. Other mechnisms will be about as easy, so
(don't tell! but...) it is not that hard to add the second server.

</li></ul>

<h3> Execution and JokeLog.txt: </h3> <ul> <li> Run your sever with multiple clients active at the same
time. Interleave requests from different clients. Capture eight output responses from one
client in joke mode, and eight in proverb mode, showing that the jokes and proverbs are
returned randomly, but not repeated until all four in each set have been sent back. Annotate
this in your JokeOutput.txt log file. <p>

</p></li><li> Repeat the process, but this time use your adminstration client to <i> interleave </i>
Joke Mode and Proverb Mode, showing that state is correctly maintained across changes between
modes.<p>

</p></li><li> Put the output from your running sessions in a text log file and ANNOTATE the
output�highlighting the randomness of the jokes, the interleaving of modes, etc. NEVER
alter any of the output data, but you can add some white space and some annotation headings to
make it easier for us to read if you like.<p>

</p></li><li> Format the presentation and submission of your work <i> exactly </i> as specified.

</li></ul>

<hr> 
<h3> Bragging Rights: </h3>

These modifications are not required, but if you complete them, let us know about it in the
checklist comments section, and post your interesting work on the forums! Be SURE to print a
comment about the extra features to the console screens at startup time, and give clear
prompting. Your JokeServer and clients MUST still run in the default way. Pass an additional
argument to your programs to turn on the extra features.<p>

</p><ul>

<li> Any cool thing you feel like doing, and telling us about.

<p> </p></li><li> It is not required that your JokeClientAdmin have the capability to shut down your server,
but it would be nice. Send the token "shutdown" from your JokeClientAdmin to shut down your
server[s]. There is a catch, however. Your request will be processed by an AdminWorker
thread. By the time you get to your JokeWorker, your JokeServer main listening thread will be
blocked waiting, and your JokeAdminServer main listening thread will also likely be blocked
waiting. Neither will automatically wake up so that they can be shut down. Even if you change a
loop-control variable for each loop to <i>false,</i> these servers will not notice it until you
wake them up with another request. To see a way of gracefully shutting down your admin server
loop with a single connection, within the worker dialog and "reaching back" to kill off the
parent that called the admin worker thread see the "HostServer" assignment. Now, how can you
kill off the main Joke listening thread?

<p></p></li><li> Make your client and server somewhat fault-tolerant by writing the state to disk after
each request at both the client side and the server side, so that if either crashes, on restart
they read the state back in from disk before resuming operation. You will need to identify your
user to the JokeClient in this case, and the user will need to have a unique user name, or be
verified by a unique ID (email address?)<p>

</p></li><li> Hard: If it is available see the associated extra credit project for creating an
asynchronous JokeServer Client, possibly that also connects to multiple JokeServers.<p>

</p></li></ul>


 

</font></font></font></body></html>